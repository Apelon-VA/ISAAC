//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.09.30 at 06:15:10 PM PDT 
//


package org.hl7.vmr.r2;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import org.hl7.cdsdt.r2.CD;
import org.hl7.cdsdt.r2.II;
import org.hl7.cdsdt.r2.IVLTS;


/**
 * A record of something of clinical relevance that is being done, has been done, can be done, or is intended or requested to be done.  A class that serves as the basis for other more specific clinical statements, such as ObservationEvent and ProcedureProposal. It is a concrete class that can be used as is or specialized as needed.
 * 
 * Naming and modeling conventions:
 * 
 * 	- in general, attribute names end in 'Code' if and only if the name of the attribute overlaps with the name of the parent class
 * 
 * 
 * 	- times are named as follows: Time is the default suffix for these attributes.  EventTime is used to distinguish the time an order is placed vs. when the ordered act should take place. EffectiveTime and TimeInterval are used when there is a desire to emphasize that a prolonged time interval (e.g., > 1 day) can be used rather than a point in time or a short time interval.  Note that regardless of the naming convention, IVL_TS attributes allow time intervals of any length.
 * 
 * 
 * 	- subjectEffectiveTime is the time that is primarily related to the subject's experience of disease or treatment events (or durations), rather than when those events were reported or recorded by the performer
 * 
 * 
 * 	- performerEventTime is the event time that is primarily related to the performer, rather than the subject.
 * 
 * 
 * 	- the state between ordering and the ordered event occurring is modeled only in cases of procedures and encounters, due to the substantial rate at which orders do not result in events.
 * 
 * 
 * Approaches to representing specific statements:
 * 
 * 	- No known allergies --> NoKnownAllergy with conditionCode reflecting the type of 'No known allergy' statements (e.g., 'No known allergy', 'No known medication allergy', 'No known food allergy')
 * 
 * 
 * 	- No known medications --> UndeliveredSubstanceAdministration with substance that is the root-level code for medications.
 * 
 * 
 * 	- No known problems --> DeniedProblem with conditionCode that is the root-level code for problems or conditions.
 * 
 * 
 * 	- Patient takes an unknown drug --> SubstanceAdministrationEvent where code for substance represents "unknown medication".
 * 
 * <p>Java class for ClinicalStatement complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ClinicalStatement">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="templateId" type="{urn:hl7-org:vmr:r2}CodedIdentifier" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="id" type="{urn:hl7-org:cdsdt:r2}II" minOccurs="0"/>
 *         &lt;element name="dataSourceType" type="{urn:hl7-org:cdsdt:r2}CD" minOccurs="0"/>
 *         &lt;element name="documentationTime" type="{urn:hl7-org:cdsdt:r2}IVL_TS" minOccurs="0"/>
 *         &lt;element name="evaluatedPersonId" type="{urn:hl7-org:cdsdt:r2}II" minOccurs="0"/>
 *         &lt;element name="attribute" type="{urn:hl7-org:vmr:r2}NameValuePair" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="comment" type="{urn:hl7-org:vmr:r2}Documentation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="relatedEntity" type="{urn:hl7-org:vmr:r2}RelatedEntity" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="relatedClinicalStatement" type="{urn:hl7-org:vmr:r2}RelatedClinicalStatement" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ClinicalStatement", propOrder = {
    "templateId",
    "id",
    "dataSourceType",
    "documentationTime",
    "evaluatedPersonId",
    "attribute",
    "comment",
    "relatedEntity",
    "relatedClinicalStatement"
})
@XmlSeeAlso({
    AdverseEventBase.class,
    OralDietBase.class,
    SupplyBase.class,
    ConditionBase.class,
    ObservationBase.class,
    ProcedureBase.class,
    GroupingClinicalStatement.class,
    GoalBase.class,
    SubstanceClinicalStatementBase.class,
    EncounterBase.class,
    CommunicationBase.class
})
public class ClinicalStatement {

    protected List<CodedIdentifier> templateId;
    protected II id;
    protected CD dataSourceType;
    protected IVLTS documentationTime;
    protected II evaluatedPersonId;
    protected List<NameValuePair> attribute;
    protected List<Documentation> comment;
    protected List<RelatedEntity> relatedEntity;
    protected List<RelatedClinicalStatement> relatedClinicalStatement;

    /**
     * Gets the value of the templateId property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the templateId property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTemplateId().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodedIdentifier }
     * 
     * 
     */
    public List<CodedIdentifier> getTemplateId() {
        if (templateId == null) {
            templateId = new ArrayList<CodedIdentifier>();
        }
        return this.templateId;
    }

    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link II }
     *     
     */
    public II getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link II }
     *     
     */
    public void setId(II value) {
        this.id = value;
    }

    /**
     * Gets the value of the dataSourceType property.
     * 
     * @return
     *     possible object is
     *     {@link CD }
     *     
     */
    public CD getDataSourceType() {
        return dataSourceType;
    }

    /**
     * Sets the value of the dataSourceType property.
     * 
     * @param value
     *     allowed object is
     *     {@link CD }
     *     
     */
    public void setDataSourceType(CD value) {
        this.dataSourceType = value;
    }

    /**
     * Gets the value of the documentationTime property.
     * 
     * @return
     *     possible object is
     *     {@link IVLTS }
     *     
     */
    public IVLTS getDocumentationTime() {
        return documentationTime;
    }

    /**
     * Sets the value of the documentationTime property.
     * 
     * @param value
     *     allowed object is
     *     {@link IVLTS }
     *     
     */
    public void setDocumentationTime(IVLTS value) {
        this.documentationTime = value;
    }

    /**
     * Gets the value of the evaluatedPersonId property.
     * 
     * @return
     *     possible object is
     *     {@link II }
     *     
     */
    public II getEvaluatedPersonId() {
        return evaluatedPersonId;
    }

    /**
     * Sets the value of the evaluatedPersonId property.
     * 
     * @param value
     *     allowed object is
     *     {@link II }
     *     
     */
    public void setEvaluatedPersonId(II value) {
        this.evaluatedPersonId = value;
    }

    /**
     * Gets the value of the attribute property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the attribute property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAttribute().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameValuePair }
     * 
     * 
     */
    public List<NameValuePair> getAttribute() {
        if (attribute == null) {
            attribute = new ArrayList<NameValuePair>();
        }
        return this.attribute;
    }

    /**
     * Gets the value of the comment property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the comment property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getComment().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Documentation }
     * 
     * 
     */
    public List<Documentation> getComment() {
        if (comment == null) {
            comment = new ArrayList<Documentation>();
        }
        return this.comment;
    }

    /**
     * Gets the value of the relatedEntity property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the relatedEntity property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRelatedEntity().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelatedEntity }
     * 
     * 
     */
    public List<RelatedEntity> getRelatedEntity() {
        if (relatedEntity == null) {
            relatedEntity = new ArrayList<RelatedEntity>();
        }
        return this.relatedEntity;
    }

    /**
     * Gets the value of the relatedClinicalStatement property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the relatedClinicalStatement property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRelatedClinicalStatement().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelatedClinicalStatement }
     * 
     * 
     */
    public List<RelatedClinicalStatement> getRelatedClinicalStatement() {
        if (relatedClinicalStatement == null) {
            relatedClinicalStatement = new ArrayList<RelatedClinicalStatement>();
        }
        return this.relatedClinicalStatement;
    }

}
